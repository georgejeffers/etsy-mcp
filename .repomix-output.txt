This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-30T13:02:25.961Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
local-research/
  bug-analysis.md
  mcp-sdk-install.md
  mcp-sdk-latest.md
  mcp-sdk-usage.md
src/
  scripts/
    auth.ts
    getAccessToken.ts
  services/
    __tests__/
      mcpServer.test.ts
    etsyApi.ts
    mcpServer.ts
    oauthServer.ts
    tokenStorage.ts
  types/
    modelcontextprotocol.d.ts
  utils/
    logger.ts
  mcp.ts
docs.md
jest.config.cjs
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="local-research/bug-analysis.md">
## Etsy MCP Bug Analysis and Fixes

Packing repository using repomix...
Querying Gemini AI using gemini-2.0-flash-thinking-exp-01-21...
## Codebase Analysis and Bug/Issue Report

After analyzing the provided codebase, focusing on potential issues and the EROFS error context, here is a detailed list of identified bugs and issues along with suggested fixes.

**Main Focus: EROFS (Read-only File System) Error**

The most likely cause of an EROFS error in this codebase is related to file system operations within the `TokenStorage` and `Logger` classes. In read-only environments (like some containerized deployments or restricted file systems), writing to the file system will fail.

**Identified Bugs and Issues:**

**1.  Token Storage File Operations in Read-only File System (Critical - EROFS Potential)**

*   **Issue:** `TokenStorage` attempts to create directories and files within the user's home directory (`~/.etsy-mcp`) to store OAuth tokens. In read-only file systems, these operations (`fs.mkdirSync`, `fs.writeFileSync`, `fs.unlinkSync`) will fail with EROFS errors.
*   **File:** `src/services/tokenStorage.ts`
*   **Code Snippets:**
    ```typescript
    const homeDir = process.env.HOME || process.env.USERPROFILE;
    const configDir = path.join(homeDir!, '.etsy-mcp');
    if (!fs.existsSync(configDir)) {
        fs.mkdirSync(configDir, { mode: 0o700 }); // Potential EROFS error
    }
    this.tokenFilePath = path.join(configDir, 'tokens.json');
    fs.writeFileSync(this.tokenFilePath, JSON.stringify(tokens, null, 2), { mode: 0o600, encoding: 'utf8' }); // Potential EROFS error
    fs.unlinkSync(this.tokenFilePath); // Potential EROFS error
    ```
*   **Suggested Fix:**
    *   **Environment Variable for Token Storage Path:** Introduce an environment variable (e.g., `ETSY_MCP_TOKEN_DIR`) to allow users to configure the token storage directory. Default to a writable temporary directory if the home directory is read-only, or consider in-memory storage as a fallback for truly read-only systems.
    *   **Check for Writable Directory:** Before attempting to create directories or write files, check if the target directory is writable. If not, log a warning and potentially fallback to in-memory storage (for access token only, refresh token would be lost on server restart).
    *   **Error Handling:** Implement proper try-catch blocks around file system operations in `TokenStorage` to gracefully handle EROFS errors. Log informative error messages and potentially indicate to the user that token persistence is disabled due to file system restrictions.
    *   **Example Implementation (Conceptual):**

        ```typescript
        // src/services/tokenStorage.ts
        import * as os from 'os'; // Import os module

        constructor() {
            const homeDir = process.env.HOME || process.env.USERPROFILE || os.tmpdir(); // Fallback to tmpdir
            const configDirEnv = process.env.ETSY_MCP_TOKEN_DIR;
            let configDir = configDirEnv ? configDirEnv : path.join(homeDir!, '.etsy-mcp');

            if (!configDirEnv) { // Only create default dir if not overridden by env var
                try {
                    if (!fs.existsSync(configDir)) {
                        fs.mkdirSync(configDir, { mode: 0o700 });
                    }
                } catch (error: any) {
                    if (error.code === 'EROFS') {
                        console.warn('Warning: Token storage directory is read-only. Tokens will not be persisted to disk. Consider setting ETSY_MCP_TOKEN_DIR to a writable location.');
                        configDir = os.tmpdir(); // Fallback to temporary directory, still might be problematic
                    } else {
                        console.error('Error creating token storage directory:', error);
                        throw error; // Or handle differently based on needs
                    }
                }
            }
            this.tokenFilePath = path.join(configDir, 'tokens.json');
        }

        public saveTokens(tokens: TokenData): void {
            try {
                // ... (rest of saveTokens code)
                fs.writeFileSync(this.tokenFilePath, JSON.stringify(tokens, null, 2), { mode: 0o600, encoding: 'utf8' });
            } catch (error: any) {
                if (error.code === 'EROFS') {
                    console.warn('Warning: File system is read-only. Failed to save tokens to disk. Tokens will be lost on server restart.');
                    // Handle in-memory storage as fallback if needed, but refresh token will be lost
                } else {
                    console.error('Error saving tokens:', error);
                    throw error;
                }
            }
        }

        public clearTokens(): void {
            try {
                if (fs.existsSync(this.tokenFilePath)) {
                    fs.unlinkSync(this.tokenFilePath);
                }
            } catch (error: any) {
                if (error.code === 'EROFS' && !fs.existsSync(this.tokenFilePath)) {
                    // Ignore EROFS if file doesn't exist (already effectively cleared)
                    return;
                } else if (error.code === 'EROFS') {
                    console.warn('Warning: File system is read-only. Failed to clear tokens from disk.');
                    // Handle in-memory storage cleanup if needed
                }
                else {
                    console.error('Error clearing tokens:', error);
                    throw error;
                }
            }
        }
        ```

**2. Logger File Operations in Read-only File System (Less Critical but Issue - EROFS Potential)**

*   **Issue:** The `Logger` class writes logs to files within the `logs` directory in the current working directory. Similar to `TokenStorage`, this will fail with EROFS errors in read-only file systems.
*   **File:** `src/utils/logger.ts`
*   **Code Snippets:**
    ```typescript
    const logsDir = path.join(process.cwd(), 'logs');
    if (!fs.existsSync(logsDir)) {
        fs.mkdirSync(logsDir); // Potential EROFS error
    }
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    this.logFile = path.join(logsDir, `oauth-${timestamp}.log`);
    this.stream = fs.createWriteStream(this.logFile, { flags: 'a' }); // Potential EROFS error
    this.stream.write(JSON.stringify(logEntry) + '
'); // Potential EROFS error
    ```
*   **Suggested Fix:**
    *   **Environment Variable for Log Directory:** Introduce an environment variable (e.g., `ETSY_MCP_LOG_DIR`) to configure the log directory. If not set, default to writing logs to `stdout` or `stderr` instead of files in read-only environments.
    *   **Check for Writable Directory:** Before creating the log directory and file, check if the directory is writable. If not, disable file logging and log to console only.
    *   **Conditional Logging:** Implement logic to check if file logging is possible. If not, fallback to console logging.
    *   **Example Implementation (Conceptual):**

        ```typescript
        // src/utils/logger.ts
        constructor() {
            const logsDirEnv = process.env.ETSY_MCP_LOG_DIR;
            let logsDir = logsDirEnv ? logsDirEnv : path.join(process.cwd(), 'logs');
            let useFileLogging = true;

            if (!logsDirEnv) { // Only check default dir if not overridden by env var
                try {
                    if (!fs.existsSync(logsDir)) {
                        fs.mkdirSync(logsDir);
                    }
                    fs.accessSync(logsDir, fs.constants.W_OK); // Check for write access
                } catch (error: any) {
                    if (error.code === 'EROFS' || error.code === 'EACCES') {
                        console.warn('Warning: Log directory is read-only or not writable. File logging disabled. Logs will be output to console only. Consider setting ETSY_MCP_LOG_DIR to a writable location.');
                        useFileLogging = false;
                    } else {
                        console.error('Error setting up log directory:', error);
                        useFileLogging = false; // Disable file logging on setup error as well
                    }
                }
            }

            if (useFileLogging) {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                this.logFile = path.join(logsDir, `oauth-${timestamp}.log`);
                this.stream = fs.createWriteStream(this.logFile, { flags: 'a' });
            } else {
                this.stream = process.stdout as any as fs.WriteStream; // Redirect to stdout (or stderr)
                this.logFile = 'stdout'; // Or some indicator
            }
        }

        log(message: string, data?: any) {
            const timestamp = new Date().toISOString();
            const logEntry = { timestamp, message, data };
            console.error(`[${timestamp}] ${message}`, data ? data : ''); // Always console log
            if (this.logFile !== 'stdout') { // Only write to file if file logging enabled
                this.stream.write(JSON.stringify(logEntry) + '
');
            }
        }
        // ... (error and close methods similar conditional logic if needed)
        ```

**3.  Hardcoded Redirect URI (Minor Issue - Configuration)**

*   **Issue:** The redirect URI `http://localhost:3003/oauth/callback` is hardcoded in both `etsyApi.ts` and `oauthServer.ts`. This might be inflexible if users want to run the server on a different port or with a different hostname in certain deployment scenarios.
*   **Files:** `src/services/etsyApi.ts`, `src/services/oauthServer.ts`
*   **Code Snippets:**
    ```typescript
    // etsyApi.ts
    this.redirectUri = process.env.REDIRECT_URI || 'http://localhost:3003/oauth/callback';

    // oauthServer.ts
    constructor(port: number = 3003) {
        this.port = port;
        // ...
    }
    private generateAuthUrl(): string {
        // ...
        redirect_uri: `http://localhost:${this.port}/oauth/callback`,
        // ...
    }
    private async exchangeCodeForTokens(code: string) {
        // ...
        redirect_uri: `http://localhost:${this.port}/oauth/callback`,
        // ...
    }
    ```
*   **Suggested Fix:**
    *   **Environment Variable for Redirect URI:** Introduce an environment variable (e.g., `ETSY_MCP_REDIRECT_URI`) to configure the redirect URI. If not set, default to `http://localhost:3003/oauth/callback`.  Ensure the port in the redirect URI matches the `OAuthServer` port or is dynamically derived.
    *   **Configuration File:** For more complex configurations, consider using a configuration file (e.g., `config.json`) to manage settings like redirect URI, ports, API keys, etc.

**4.  Insecure Token Storage Permissions (Minor Security Issue)**

*   **Issue:** While the code attempts to set file permissions to `0o600` for the `tokens.json` file (read/write for owner only), the directory permission `0o700` (read/write/execute for owner only) for `.etsy-mcp` might not be sufficient to prevent other users on the same system from potentially listing the directory and inferring the existence of sensitive token files.
*   **File:** `src/services/tokenStorage.ts`
*   **Code Snippet:**
    ```typescript
    if (!fs.existsSync(configDir)) {
        fs.mkdirSync(configDir, { mode: 0o700 });
    }
    fs.writeFileSync(this.tokenFilePath, JSON.stringify(tokens, null, 2), { mode: 0o600, encoding: 'utf8' });
    ```
*   **Suggested Fix:**
    *   **Stricter Directory Permissions (Optional):** Consider setting directory permissions to `0o700` and ensuring that the parent directory also has restrictive permissions to limit access as much as possible. However, relying solely on file system permissions for security is generally not recommended for highly sensitive data.
    *   **Alternative Secure Storage (Recommended for Production):** For production deployments, consider using more secure storage mechanisms for OAuth tokens, such as:
        *   **Operating System's Credential Storage:** Use OS-level credential storage (like Keychain on macOS, Credential Manager on Windows, or Secret Service API on Linux) if available and suitable for the deployment environment.
        *   **Dedicated Secrets Management Service:** Integrate with a secrets management service (like HashiCorp Vault, AWS Secrets Manager, Azure Key Vault, Google Cloud Secret Manager) for more robust and centralized secret management, especially in cloud environments.
        *   **Encryption at Rest:** If storing tokens in files is unavoidable, encrypt the token file at rest using a strong encryption algorithm and a securely managed encryption key.

**5.  Missing Input Validation and Sanitization (Potential Vulnerability - Medium)**

*   **Issue:** The code, especially in `mcpServer.ts` and `etsyApi.ts`, receives input parameters (like `shop_id`, `listing_data`, etc.) from MCP requests and API calls. There's no explicit input validation or sanitization implemented to prevent potential injection attacks (e.g., command injection, cross-site scripting if responses are displayed in web UI in a client application, although less likely in this server context).
*   **Files:** `src/services/mcpServer.ts`, `src/services/etsyApi.ts`
*   **Code Example (mcpServer.ts - create_listing tool):**
    ```typescript
    this.server.tool(
        'create_listing',
        'Create a new Etsy listing',
        createListingSchema,
        async (args, extra) => {
            // ...
            const listingData = { // Potentially unsafe if args.listing_data contains malicious input
                ...args.listing_data,
                price: parseFloat(args.listing_data.price),
                quantity: parseInt(args.listing_data.quantity, 10),
                taxonomy_id: parseInt(args.listing_data.taxonomy_id, 10)
            };
            const newListing = await this.etsyApi.createListing(
                args.shop_id, // Potentially unsafe if args.shop_id is malicious
                listingData,
                tokens.access_token
            );
            // ...
        }
    );
    ```
*   **Suggested Fix:**
    *   **Schema Validation with Zod (Partially Implemented, Enhance):** You are already using Zod for schema definition in `mcpServer.ts`. Enhance the schemas to include more specific validation rules (e.g., string length limits, allowed character sets, number ranges, enum values) to ensure input data conforms to expected formats and constraints.
    *   **Input Sanitization:** Before using input data in API requests or responses, sanitize it to remove or escape potentially harmful characters. Libraries like `DOMPurify` (for HTML sanitization, if responses might be rendered in a browser) or general-purpose sanitization functions can be used. For simple cases, encoding or escaping special characters might suffice.
    *   **Error Handling for Invalid Input:** If input validation fails, return informative error messages to the MCP client indicating the invalid parameters.

**6.  Missing Refresh Token Handling and Token Expiration (Potential Functionality Issue - Medium)**

*   **Issue:** While the code includes a `refreshToken` function in `etsyApi.ts`, there isn't explicit logic to automatically refresh access tokens when they expire. The `TokenStorage` saves `expires_at`, but it's only checked when getting tokens, not actively used to refresh tokens before making API calls. If an access token expires, API calls will start failing until the user re-authenticates.
*   **Files:** `src/services/etsyApi.ts`, `src/services/tokenStorage.ts`, `src/services/mcpServer.ts`
*   **Code Snippets:**
    ```typescript
    // tokenStorage.ts
    public getTokens(): TokenData | null {
        // ...
        if (tokens.expires_at && tokens.expires_at < Date.now()) {
            return null; // Returns null if expired, but doesn't trigger refresh
        }
        return tokens;
    }

    // etsyApi.ts
    async refreshToken(refreshToken: string): Promise<OAuthTokenResponse> {
        // ... (Refresh token logic exists)
    }
    ```
*   **Suggested Fix:**
    *   **Token Refresh Interceptor/Middleware:** Implement an interceptor or middleware in `etsyApi.ts` or within the MCP tool handlers in `mcpServer.ts`. Before making an authenticated API request, check if the access token is close to expiration (e.g., within a few minutes). If so, use the refresh token to obtain a new access token and refresh token pair. Update the tokens in `TokenStorage` and then proceed with the API request using the new access token.
    *   **Retry Mechanism:** If an API request fails due to an expired token (Etsy API might return a specific error code for this), catch the error, attempt to refresh the token, and retry the API request with the new token. Implement retry limits to prevent infinite loops if refresh token also fails.
    *   **Background Token Refresh (More Complex):** For a more robust solution, implement a background task or scheduler to proactively refresh tokens before they expire. This requires more complex state management and concurrency handling.

**7.  Lack of Comprehensive Error Handling in API Calls (Minor - Robustness)**

*   **Issue:** While `etsyApi.ts` has some basic error handling (checking `axios.isAxiosError`), it could be more comprehensive. It primarily throws generic errors like "API request failed". More specific error handling and logging would be beneficial for debugging and providing better error messages to clients.
*   **File:** `src/services/etsyApi.ts`
*   **Code Snippets:**
    ```typescript
    private async makeRequest<T>(endpoint: string, method: 'GET' | 'POST' = 'GET', data: any = null, accessToken?: string): Promise<T> {
        // ...
        } catch (error) {
            if (axios.isAxiosError(error)) {
                throw new Error(`API request failed: ${error.response?.data?.error || error.message}`); // Generic error
            }
            throw error;
        }
    }
    ```
*   **Suggested Fix:**
    *   **Specific Error Handling:** In `makeRequest` and other API functions, inspect `error.response` (if it's an `AxiosError`) to get more detailed error information from the Etsy API (status code, error codes, error messages).
    *   **Log API Error Details:** Log the full error response from the Etsy API (status code, headers, data) when API calls fail. This will provide valuable context for debugging.
    *   **Custom Error Types/Codes:** Consider defining custom error types or error codes to represent different categories of API errors (e.g., authentication errors, rate limit errors, resource not found errors, server errors). This will allow MCP clients to handle errors more specifically.
    *   **Example Improvement:**

        ```typescript
        // src/services/etsyApi.ts
        private async makeRequest<T>(endpoint: string, method: 'GET' | 'POST' = 'GET', data: any = null, accessToken?: string): Promise<T> {
            try {
                // ...
            } catch (error) {
                if (axios.isAxiosError(error)) {
                    const apiError = error.response?.data;
                    const errorMessage = apiError?.error_description || apiError?.error || error.message || 'API request failed';
                    const statusCode = error.response?.status;
                    logger.error(`Etsy API request failed for endpoint: ${endpoint}`, {
                        statusCode,
                        apiError,
                        fullError: error
                    });
                    throw new Error(`Etsy API error: ${errorMessage} (Status Code: ${statusCode})`); // More informative error
                }
                logger.error(`Generic error during Etsy API request for endpoint: ${endpoint}`, error);
                throw new Error(`API request failed: ${error.message}`); // Fallback generic error
            }
        }
        ```

**8.  Lack of Rate Limit Handling (Potential Service Disruption - Medium)**

*   **Issue:** The Etsy API has rate limits. The code doesn't explicitly handle rate limit responses (e.g., HTTP 429 Too Many Requests). If rate limits are exceeded, API calls will fail, potentially disrupting functionality.
*   **Files:** `src/services/etsyApi.ts`, `src/services/mcpServer.ts`
*   **Suggested Fix:**
    *   **Rate Limit Detection:** In `makeRequest` in `etsyApi.ts`, check for HTTP 429 status codes in the response.
    *   **Retry with Backoff:** When a 429 response is received, implement a retry mechanism with exponential backoff. Wait for a progressively longer duration before retrying the request. The `Retry-After` header in the 429 response (if provided by Etsy API) can be used to determine the wait time.
    *   **Rate Limit Exceeded Error:** If retries fail after a certain number of attempts or a timeout, return a specific error to the MCP client indicating that the rate limit has been exceeded.
    *   **Consider Rate Limiting Libraries:** Explore using libraries like `axios-rate-limit` or similar to simplify rate limit handling with Axios.

**9.  Missing Documentation for Environment Variables (Minor - Usability)**

*   **Issue:** The documentation (`docs.md` and `README.md`) doesn't explicitly mention the environment variables that can be used to configure the server (e.g., `ETSY_MCP_TOKEN_DIR`, `ETSY_MCP_LOG_DIR`, `ETSY_MCP_REDIRECT_URI` if you implement the suggested fixes).
*   **Files:** `docs.md`, `README.md`
*   **Suggested Fix:**
    *   **Update Documentation:** Update `docs.md` and `README.md` to include a section on "Environment Variables" and list all configurable environment variables with their descriptions and default values. This will make the server more user-friendly and configurable.

**10. Potential Vulnerability: Open Redirect in OAuth Flow (Low - Security Best Practice)**

*   **Issue:** While less likely to be directly exploited in this server-side context, the OAuth flow could potentially be vulnerable to open redirect attacks if not carefully handled in a client application that uses the authorization URL. The `state` parameter is used, which helps mitigate CSRF but doesn't fully prevent open redirects if the client application itself mishandles redirects after authentication.
*   **Files:** `src/services/oauthServer.ts`
*   **Code Snippets:**
    ```typescript
    private generateAuthUrl(): string {
        // ...
        state: Math.random().toString(36).substring(7),
        // ...
    }
    ```
*   **Suggested Fix (Best Practice):**
    *   **Strict Redirect URI Validation:** In a client application that initiates the OAuth flow using the generated authorization URL, strictly validate the `redirect_uri` parameter against a predefined whitelist of allowed redirect URIs. Do not blindly redirect to the `redirect_uri` provided in the authorization response.
    *   **In This Server Context (Less Critical):** Since this server primarily acts as an MCP server and doesn't directly handle user-facing redirects, the open redirect risk is lower. However, if you anticipate exposing the OAuth flow to client applications, consider documenting the importance of redirect URI validation for client developers.

**Summary of Critical Issues and Fixes for EROFS:**

The most critical issue is the potential for EROFS errors due to file system operations in read-only environments. The primary fixes revolve around:

1.  **Environment variables for file paths:**  Allow configuration of token and log directories.
2.  **Writable directory checks:** Detect read-only file systems and gracefully handle them (disable file persistence/logging or fallback to alternatives like in-memory storage/console logging).
3.  **Robust error handling:** Implement try-catch blocks and specific error handling for file system operations, especially for EROFS errors.

By addressing these issues, you can significantly improve the robustness and deployability of the Etsy MCP server, especially in containerized or restricted environments where read-only file systems are common. Remember to prioritize security best practices and thorough testing after implementing these fixes.
</file>

<file path="local-research/mcp-sdk-install.md">
Querying Perplexity AI using sonar-pro for: Model Context Protocol TypeScript SDK package name and installation
The Model Context Protocol TypeScript SDK package name is "@modelcontextprotocol/sdk". To install it, you can use npm with the following command:

```
npm install @modelcontextprotocol/sdk
```

This package allows you to build MCP clients and servers, enabling standardized interactions between applications and LLMs[1][7].

citations:
1. https://www.youtube.com/watch?v=kXuRJXEzrE0
2. https://www.youtube.com/watch?v=MC2BwMGFRx4
3. https://www.speakeasy.com/docs/customize/typescript/model-context-protocol/model-context-protocol
4. https://hackteam.io/blog/build-your-first-mcp-server-with-typescript-in-under-10-minutes/
5. https://developer.ibm.com/tutorials/awb-handle-remote-tool-calling-model-context-protocol/
6. https://github.com/modelcontextprotocol
7. https://www.speakeasy.com/post/release-model-context-protocol
8. https://www.speakeasy.com/docs/customize/typescript/model-context-protocol
9. https://developers.cloudflare.com/agents/model-context-protocol/tools/
10. https://modelcontextprotocol.io/development/updates
11. https://github.com/modelcontextprotocol/typescript-sdk
12. https://sourceforge.net/projects/model-cont-protocol-t.mirror/
</file>

<file path="local-research/mcp-sdk-latest.md">
Querying Perplexity AI using sonar-pro for: Model Context Protocol SDK latest version and installation guide
The latest version of the Model Context Protocol (MCP) TypeScript SDK is 1.7.0, released 14 days ago[14].

To install the MCP TypeScript SDK, use the following npm command:

```
npm install @modelcontextprotocol/sdk
```

Here's a quick guide to get started with the SDK:

1. Create a simple MCP server:

```typescript
import { McpServer, ResourceTemplate } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// Create an MCP server
const server = new McpServer({ name: "Demo", version: "1.0.0" });

// Add an addition tool
server.tool("add", 
  { a: z.number(), b: z.number() },
  async ({ a, b }) => ({ content: [{ type: "text", text: String(a + b) }] })
);

// Add a dynamic greeting resource
server.resource(
  "greeting",
  new ResourceTemplate("greeting://{name}", { list: undefined }),
  async (uri, { name }) => ({ contents: [{ uri: uri.href, text: `Hello, ${name}` }] })
);

// Start receiving messages on stdin and sending messages on stdout
const transport = new StdioServerTransport();
await server.connect(transport);
```

2. Run your server:

To run your MCP server, save the code in a file (e.g., `server.js`) and execute it using Node.js:

```
node server.js
```

This will start your MCP server, which can now be connected to by MCP clients[14].

For more advanced usage and client implementation, refer to the SDK documentation and examples provided in the package.

citations:
1. https://modelcontextprotocol.io/sdk/java/mcp-overview
2. https://www.youtube.com/watch?v=MC2BwMGFRx4
3. https://docs.anthropic.com/en/docs/agents-and-tools/mcp
4. https://www.microsoft.com/en-us/microsoft-copilot/blog/copilot-studio/introducing-model-context-protocol-mcp-in-copilot-studio-simplified-integration-with-ai-apps-and-agents/
5. https://modelcontextprotocol.io/quickstart/client
6. https://modelcontextprotocol.io/development/updates
7. https://www.youtube.com/watch?v=KiNyvT02HJM
8. https://www.anthropic.com/news/model-context-protocol
9. https://modelcontextprotocol.io/quickstart/server
10. https://www.npmjs.com/package/@modelcontextprotocol/sdk/v/0.6.1
11. https://www.datacamp.com/tutorial/mcp-model-context-protocol
12. https://github.com/modelcontextprotocol
13. https://glama.ai/blog/2024-11-25-model-context-protocol-quickstart
14. https://www.npmjs.com/package/@modelcontextprotocol/sdk
15. https://github.com/modelcontextprotocol/typescript-sdk
16. https://spring.io/blog/2025/02/14/mcp-java-sdk-released-2/
17. https://www.speakeasy.com/docs/customize/typescript/model-context-protocol/model-context-protocol
18. https://www.speakeasy.com/post/release-model-context-protocol
19. https://github.com/modelcontextprotocol/python-sdk
</file>

<file path="local-research/mcp-sdk-usage.md">
Querying Perplexity AI using sonar-pro for: Model Context Protocol SDK import and usage example
To import and use the Model Context Protocol (MCP) SDK in TypeScript, you can follow this example:

```typescript
import { MCPServer } from '@modelcontextprotocol/typescript-sdk';

const server = new MCPServer('weather-server');

server.addTool({
  name: 'get-weather',
  description: 'Get the current weather for a given city',
  args: {
    city: {
      type: 'string',
      description: 'The name of the city'
    }
  },
  execute: async (args) => {
    const { city } = args;
    // Implement weather fetching logic here
    const weather = await fetchWeather(city);
    return { type: 'text', text: `The weather in ${city} is ${weather}` };
  }
});

server.start();
```

This example demonstrates:

1. Importing the MCPServer class from the SDK
2. Creating a new server instance
3. Adding a tool called 'get-weather' with a description and arguments
4. Implementing the execute function for the tool
5. Starting the server

The SDK allows you to easily create MCP servers that can expose data and functionality to LLM applications in a standardized way[8].

citations:
1. https://nshipster.com/model-context-protocol/
2. https://www.youtube.com/watch?v=MC2BwMGFRx4
3. https://www.youtube.com/watch?v=eD0uBLr-eP8
4. https://www.speakeasy.com/post/release-model-context-protocol
5. https://modelcontextprotocol.io/quickstart/server
6. https://www.datacamp.com/tutorial/mcp-model-context-protocol
7. https://github.com/modelcontextprotocol/python-sdk
8. https://github.com/modelcontextprotocol/typescript-sdk
</file>

<file path="src/scripts/auth.ts">
import { etsyApi } from '../services/etsyApi.js';
async function main() {
    try {
        // Step 1: Get the authorization URL
        const authUrl = etsyApi.getAuthorizationUrl();
        console.log('Please visit this URL to authorize the application:');
        console.log(authUrl);
        // Note: In a real application, you would:
        // 1. Start a local server to handle the callback
        // 2. Open the auth URL in a browser
        // 3. Wait for the user to authorize and redirect back to your callback URL
        // 4. Extract the authorization code from the callback URL
        // 5. Exchange the code for an access token
        // For demonstration purposes, we'll ask the user to input the authorization code
        const readline = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
        });
        readline.question('Please enter the authorization code from the callback URL: ', async (code: string) => {
            try {
                // Step 2: Exchange the authorization code for an access token
                const tokenResponse = await etsyApi.getAccessToken(code);
                console.log('\nAccess token received successfully!');
                console.log('Access Token:', tokenResponse.access_token);
                console.log('Refresh Token:', tokenResponse.refresh_token);
                console.log('Expires in:', tokenResponse.expires_in, 'seconds');
                console.log('Scope:', tokenResponse.scope);
                // Step 3: Demonstrate token refresh
                console.log('\nDemonstrating token refresh...');
                const refreshResponse = await etsyApi.refreshToken(tokenResponse.refresh_token);
                console.log('New access token received successfully!');
                console.log('New Access Token:', refreshResponse.access_token);
                console.log('New Refresh Token:', refreshResponse.refresh_token);
                console.log('New Expires in:', refreshResponse.expires_in, 'seconds');
                readline.close();
            } catch (error) {
                console.error('Error during authentication:', error);
                readline.close();
            }
        });
    } catch (error) {
        console.error('Error:', error);
    }
}
main();
</file>

<file path="src/scripts/getAccessToken.ts">
import axios from 'axios';
import * as dotenv from 'dotenv';
import querystring from 'querystring';
import open from 'open';
dotenv.config();
const ETSY_API_KEY = process.env.ETSY_API_KEY;
const ETSY_CLIENT_SECRET = process.env.ETSY_CLIENT_SECRET;
const REDIRECT_URI = 'http://localhost:3000/oauth/callback';
if (!ETSY_API_KEY || !ETSY_CLIENT_SECRET) {
    console.error('Please set ETSY_API_KEY and ETSY_CLIENT_SECRET in your .env file');
    process.exit(1);
}
async function getAccessToken() {
    try {
        // Step 1: Generate authorization URL
        const authParams = {
            client_id: ETSY_API_KEY,
            redirect_uri: REDIRECT_URI,
            response_type: 'code',
            scope: 'listings_r listings_w shops_r',
            state: Math.random().toString(36).substring(7)
        };
        const authUrl = `https://www.etsy.com/oauth/connect?${querystring.stringify(authParams)}`;
        console.log('Opening browser for Etsy authorization...');
        await open(authUrl);
        // Step 2: Wait for user to input the code from the redirect URL
        console.log('\nAfter authorizing, you will be redirected to a URL that looks like:');
        console.log('http://localhost:3000/oauth/callback?code=YOUR_CODE&state=STATE');
        console.log('\nPlease paste the full redirect URL here:');
        const redirectUrl = await new Promise<string>((resolve) => {
            process.stdin.once('data', (data) => {
                resolve(data.toString().trim());
            });
        });
        // Step 3: Extract the code from the redirect URL
        const urlParams = new URLSearchParams(new URL(redirectUrl).search);
        const code = urlParams.get('code');
        if (!code) {
            throw new Error('No authorization code found in the redirect URL');
        }
        // Step 4: Exchange the code for an access token
        const tokenEndpoint = 'https://api.etsy.com/v3/public/oauth/token';
        const authString = Buffer.from(`${ETSY_API_KEY}:${ETSY_CLIENT_SECRET}`).toString('base64');
        const response = await axios.post(tokenEndpoint, querystring.stringify({
            grant_type: 'authorization_code',
            client_id: ETSY_API_KEY,
            redirect_uri: REDIRECT_URI,
            code: code
        }), {
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Authorization': `Basic ${authString}`
            }
        });
        // Step 5: Save the tokens to .env file
        const { access_token, refresh_token } = response.data;
        // Update .env file with the new tokens
        const envContent = `
ETSY_API_KEY=${ETSY_API_KEY}
ETSY_CLIENT_SECRET=${ETSY_CLIENT_SECRET}
ETSY_ACCESS_TOKEN=${access_token}
ETSY_REFRESH_TOKEN=${refresh_token}
`;
        console.log('\nSuccess! Your access token has been saved to .env');
        console.log('You can now use this token for API calls.');
        return { access_token, refresh_token };
    } catch (error: any) {
        console.error('Error getting access token:', error.message);
        if (error.response) {
            console.error('Error details:', error.response.data);
        }
        process.exit(1);
    }
}
getAccessToken();
</file>

<file path="src/services/__tests__/mcpServer.test.ts">
import { EtsyMCPServer } from '../mcpServer.js';
import { OAuthServer } from '../oauthServer.js';
import { TokenStorage } from '../tokenStorage.js';
import { etsyApi } from '../etsyApi.js';
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
jest.mock('../oauthServer.js');
jest.mock('../tokenStorage.js');
jest.mock('../etsyApi.js');
jest.mock('@modelcontextprotocol/sdk/server/index.js');
describe('EtsyMCPServer', () => {
    let mcpServer: EtsyMCPServer;
    let mockOAuthServer: jest.Mocked<OAuthServer>;
    let mockTokenStorage: jest.Mocked<TokenStorage>;
    let mockEtsyApi: jest.Mocked<typeof etsyApi>;
    let mockServer: jest.Mocked<Server>;
    beforeEach(() => {
        mockOAuthServer = {
            start: jest.fn(),
            stop: jest.fn(),
            getAuthUrl: jest.fn()
        } as any;
        mockTokenStorage = {
            getTokens: jest.fn(),
            setTokens: jest.fn()
        } as any;
        mockEtsyApi = {
            getListings: jest.fn(),
            getShopDetails: jest.fn(),
            createListing: jest.fn()
        } as any;
        mockServer = {
            setRequestHandler: jest.fn(),
            connect: jest.fn(),
            close: jest.fn()
        } as any;
        (Server as jest.Mock).mockImplementation(() => mockServer);
        (OAuthServer as jest.Mock).mockImplementation(() => mockOAuthServer);
        (TokenStorage.getInstance as jest.Mock).mockReturnValue(mockTokenStorage);
        mcpServer = new EtsyMCPServer(mockOAuthServer);
    });
    describe('Server Initialization', () => {
        it('should initialize with correct name and version', () => {
            expect(Server).toHaveBeenCalledWith({
                name: 'Etsy API',
                version: '1.0.0',
                capabilities: expect.any(Object)
            });
        });
    });
    describe('Tool Capabilities', () => {
        it('should have correct authentication tool capabilities', () => {
            const capabilities = (Server as jest.Mock).mock.calls[0][0].capabilities.tools;
            expect(capabilities['mcp.authenticate']).toEqual({
                description: 'Authenticate with Etsy API. This will open a browser window for OAuth authentication.',
                parameters: {
                    type: 'object',
                    properties: {}
                }
            });
        });
        it('should have correct get listings tool capabilities', () => {
            const capabilities = (Server as jest.Mock).mock.calls[0][0].capabilities.tools;
            expect(capabilities['mcp.get_listings']).toEqual({
                description: 'Get all listings for a shop',
                parameters: {
                    type: 'object',
                    properties: {
                        shop_id: {
                            type: 'number',
                            description: 'The ID of the Etsy shop'
                        }
                    },
                    required: ['shop_id']
                }
            });
        });
        it('should have correct create listing tool capabilities', () => {
            const capabilities = (Server as jest.Mock).mock.calls[0][0].capabilities.tools;
            expect(capabilities['mcp.create_listing']).toEqual({
                description: 'Create a new Etsy listing',
                parameters: {
                    type: 'object',
                    properties: {
                        shop_id: {
                            type: 'number',
                            description: 'The ID of the Etsy shop'
                        },
                        listing_data: {
                            type: 'object',
                            properties: {
                                title: {
                                    type: 'string',
                                    description: 'Title of the listing'
                                },
                                description: {
                                    type: 'string',
                                    description: 'Description of the listing'
                                },
                                price: {
                                    type: 'number',
                                    description: 'Price of the listing'
                                },
                                quantity: {
                                    type: 'number',
                                    description: 'Quantity available'
                                },
                                who_made: {
                                    type: 'string',
                                    description: 'Who made the item (i_did, collective, someone_else)'
                                },
                                when_made: {
                                    type: 'string',
                                    description: 'When the item was made (made_to_order, 2020_2024, etc)'
                                },
                                taxonomy_id: {
                                    type: 'number',
                                    description: 'Etsy category ID'
                                },
                                type: {
                                    type: 'string',
                                    description: 'Type of listing (physical or digital)'
                                }
                            },
                            required: ['title', 'description', 'price', 'quantity', 'who_made', 'when_made', 'taxonomy_id', 'type']
                        }
                    },
                    required: ['shop_id', 'listing_data']
                }
            });
        });
    });
    describe('Request Handlers', () => {
        it('should handle authentication request', async () => {
            const authUrl = 'http://example.com/auth';
            mockOAuthServer.start.mockResolvedValue(undefined);
            mockOAuthServer.getAuthUrl.mockReturnValue(authUrl);
            const request = {
                method: 'tools/call',
                params: {
                    name: 'mcp.authenticate',
                    arguments: {}
                }
            };
            const signal = new AbortController().signal;
            // Get the handler function that was registered
            const handler = mockServer.setRequestHandler.mock.calls[0][1];
            const result = await handler(request, { signal });
            expect(result).toEqual({
                content: [{
                    type: 'text',
                    text: 'Please complete the authentication in your browser. The window will close automatically when done.'
                }]
            });
        });
        it('should handle get listings request', async () => {
            const mockListings = [{ id: 1, title: 'Test Listing' }];
            mockTokenStorage.getTokens.mockReturnValue({ access_token: 'test-token' });
            mockEtsyApi.getListings.mockResolvedValue(mockListings);
            const request = {
                method: 'tools/call',
                params: {
                    name: 'mcp.get_listings',
                    arguments: {
                        shop_id: 123
                    }
                }
            };
            const signal = new AbortController().signal;
            // Get the handler function that was registered
            const handler = mockServer.setRequestHandler.mock.calls[1][1];
            const result = await handler(request, { signal });
            expect(result).toEqual({
                content: [{
                    type: 'text',
                    text: JSON.stringify(mockListings, null, 2)
                }]
            });
        });
        it('should handle get shop details request', async () => {
            const mockShopDetails = { id: 123, name: 'Test Shop' };
            mockTokenStorage.getTokens.mockReturnValue({ access_token: 'test-token' });
            mockEtsyApi.getShopDetails.mockResolvedValue(mockShopDetails);
            const request = {
                method: 'tools/call',
                params: {
                    name: 'mcp.get_shop_details',
                    arguments: {
                        shop_id: 123
                    }
                }
            };
            const signal = new AbortController().signal;
            // Get the handler function that was registered
            const handler = mockServer.setRequestHandler.mock.calls[2][1];
            const result = await handler(request, { signal });
            expect(result).toEqual({
                content: [{
                    type: 'text',
                    text: JSON.stringify(mockShopDetails, null, 2)
                }]
            });
        });
        it('should handle create listing request', async () => {
            const mockNewListing = { id: 1, title: 'New Listing' };
            mockTokenStorage.getTokens.mockReturnValue({ access_token: 'test-token' });
            mockEtsyApi.createListing.mockResolvedValue(mockNewListing);
            const request = {
                method: 'tools/call',
                params: {
                    name: 'mcp.create_listing',
                    arguments: {
                        shop_id: 123,
                        listing_data: {
                            title: 'Test Listing',
                            description: 'Test Description',
                            price: 10,
                            quantity: 1,
                            who_made: 'i_did',
                            when_made: '2020_2024',
                            taxonomy_id: 1,
                            type: 'physical'
                        }
                    }
                }
            };
            const signal = new AbortController().signal;
            // Get the handler function that was registered
            const handler = mockServer.setRequestHandler.mock.calls[3][1];
            const result = await handler(request, { signal });
            expect(result).toEqual({
                content: [{
                    type: 'text',
                    text: JSON.stringify(mockNewListing, null, 2)
                }]
            });
        });
        it('should handle unauthenticated request', async () => {
            mockTokenStorage.getTokens.mockReturnValue(null);
            const request = {
                method: 'tools/call',
                params: {
                    name: 'mcp.get_listings',
                    arguments: {
                        shop_id: 123
                    }
                }
            };
            const signal = new AbortController().signal;
            // Get the handler function that was registered
            const handler = mockServer.setRequestHandler.mock.calls[1][1];
            const result = await handler(request, { signal });
            expect(result).toEqual({
                content: [{
                    type: 'text',
                    text: 'Not authenticated. Please authenticate first.'
                }],
                isError: true
            });
        });
    });
});
</file>

<file path="src/services/etsyApi.ts">
import axios from 'axios';
import * as dotenv from 'dotenv';
import crypto from 'crypto';
import { config } from 'dotenv';
dotenv.config();
interface ListingData {
    title: string;
    description: string;
    price: number;
    quantity: number;
    who_made: string;
    when_made: string;
    taxonomy_id: number;
    type: string;
}
interface OAuthTokenResponse {
    access_token: string;
    refresh_token: string;
    expires_in: number;
    token_type: string;
    scope: string;
}
export class EtsyApiClient {
    private baseURL: string;
    private apiKey: string;
    private clientSecret: string;
    private redirectUri: string;
    private codeVerifier: string | null = null;
    private accessToken: string | null = null;
    constructor(port: number = 3003) {
        this.baseURL = 'https://api.etsy.com/v3';
        this.apiKey = process.env.ETSY_API_KEY || '';
        this.clientSecret = process.env.ETSY_CLIENT_SECRET || '';
        // Get host from environment or use localhost
        const host = process.env.ETSY_MCP_HOST || 'localhost';
        this.redirectUri = process.env.ETSY_MCP_REDIRECT_URI || `http://${host}:${port}/oauth/callback`;
        if (!this.apiKey || !this.clientSecret) {
            throw new Error('ETSY_API_KEY and ETSY_CLIENT_SECRET must be set in environment variables');
        }
    }
    // Generate PKCE code verifier and challenge
    private generatePKCE(): { codeVerifier: string; codeChallenge: string } {
        // Only generate new PKCE if not already set
        if (!this.codeVerifier) {
            this.codeVerifier = crypto.randomBytes(32)
                .toString('base64')
                .replace(/[^a-zA-Z0-9]/g, '')
                .substring(0, 128);
        }
        const codeChallenge = crypto
            .createHash('sha256')
            .update(this.codeVerifier)
            .digest('base64')
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');
        return { codeVerifier: this.codeVerifier, codeChallenge };
    }
    // Get the OAuth authorization URL
    getAuthorizationUrl(): string {
        const { codeChallenge } = this.generatePKCE();
        const scopes = 'listings_r listings_w shops_r shops_w';
        const params = new URLSearchParams({
            response_type: 'code',
            client_id: this.apiKey,
            redirect_uri: this.redirectUri,
            scope: scopes,
            code_challenge: codeChallenge,
            code_challenge_method: 'S256'
        });
        return `https://www.etsy.com/oauth/connect?${params.toString()}`;
    }
    // Exchange authorization code for access token
    async getAccessToken(code: string): Promise<OAuthTokenResponse> {
        const auth = Buffer.from(`${this.apiKey}:${this.clientSecret}`).toString('base64');
        const headers = {
            'Authorization': `Basic ${auth}`,
            'Content-Type': 'application/x-www-form-urlencoded'
        };
        try {
            const response = await axios.post(
                `${this.baseURL}/public/oauth/token`,
                new URLSearchParams({
                    grant_type: 'authorization_code',
                    client_id: this.apiKey,
                    redirect_uri: this.redirectUri,
                    code: code
                }),
                { headers }
            );
            return response.data;
        } catch (error) {
            if (axios.isAxiosError(error)) {
                throw new Error(`Failed to get access token: ${error.response?.data?.error || error.message}`);
            }
            throw error;
        }
    }
    // Refresh access token
    async refreshToken(refreshToken: string): Promise<OAuthTokenResponse> {
        const params = new URLSearchParams({
            grant_type: 'refresh_token',
            client_id: this.apiKey,
            refresh_token: refreshToken
        });
        try {
            const response = await axios.post(
                'https://api.etsy.com/v3/public/oauth/token',
                params.toString(),
                {
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    }
                }
            );
            this.accessToken = response.data.access_token;
            return response.data;
        } catch (error: any) {
            const errorMessage = error.response?.data?.error || error.message;
            console.error('Error refreshing token:', {
                status: error.response?.status,
                data: error.response?.data,
                message: errorMessage
            });
            throw new Error(`Failed to refresh token: ${errorMessage}`);
        }
    }
    // Make authenticated API request
    private async makeRequest<T>(endpoint: string, method: 'GET' | 'POST' = 'GET', data: any = null, accessToken?: string): Promise<T> {
        const headers = this.getHeaders(accessToken);
        try {
            const response = await axios({
                method,
                url: `${this.baseURL}${endpoint}`,
                headers,
                data
            });
            return response.data;
        } catch (error) {
            if (axios.isAxiosError(error)) {
                throw new Error(`API request failed: ${error.response?.data?.error || error.message}`);
            }
            throw error;
        }
    }
    // Shop endpoints
    async getShopDetails(shopId: string, accessToken: string) {
        return this.makeRequest(`/application/shops/${shopId}`, 'GET', null, accessToken);
    }
    // Listing endpoints
    async getListings(shopId: string, accessToken: string) {
        return this.makeRequest(`/application/shops/${shopId}/listings/active`, 'GET', null, accessToken);
    }
    async createListing(shopId: string, listingData: any, accessToken: string) {
        return this.makeRequest(`/application/shops/${shopId}/listings`, 'POST', listingData, accessToken);
    }
    setAccessToken(token: string) {
        this.accessToken = token;
    }
    private getHeaders(accessToken?: string): Record<string, string> {
        const headers: Record<string, string> = {
            'x-api-key': this.apiKey,
            'Content-Type': 'application/json'
        };
        if (accessToken) {
            headers['Authorization'] = `Bearer ${accessToken}`;
        }
        return headers;
    }
}
// Export a singleton instance
export const etsyApi = new EtsyApiClient();
config();
const ETSY_API_BASE_URL = 'https://api.etsy.com/v3';
export const etsyApiLegacy = {
  async getListings(shopId: string, accessToken: string) {
    try {
      const response = await axios.get(`${ETSY_API_BASE_URL}/application/shops/${shopId}/listings/active`, {
        headers: {
          'x-api-key': process.env.ETSY_API_KEY,
          'Authorization': `Bearer ${accessToken}`
        }
      });
      return response.data;
    } catch (error) {
      console.error('Error fetching listings:', error);
      throw error;
    }
  },
  async getShopDetails(shopId: string, accessToken: string) {
    try {
      const response = await axios.get(`${ETSY_API_BASE_URL}/application/shops/${shopId}`, {
        headers: {
          'x-api-key': process.env.ETSY_API_KEY,
          'Authorization': `Bearer ${accessToken}`
        }
      });
      return response.data;
    } catch (error) {
      console.error('Error fetching shop details:', error);
      throw error;
    }
  },
  async createListing(shopId: string, listingData: any, accessToken: string) {
    try {
      const response = await axios.post(`${ETSY_API_BASE_URL}/application/shops/${shopId}/listings`, listingData, {
        headers: {
          'x-api-key': process.env.ETSY_API_KEY,
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        }
      });
      return response.data;
    } catch (error) {
      console.error('Error creating listing:', error);
      throw error;
    }
  }
};
</file>

<file path="src/services/mcpServer.ts">
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import type { Protocol } from '@modelcontextprotocol/sdk/shared/protocol.js';
import { OAuthServer } from './oauthServer.js';
import { etsyApi } from './etsyApi.js';
import { TokenStorage } from './tokenStorage.js';
import { z } from 'zod';
import open from 'open';
// Define schemas using z.object() directly
const getListingsSchema = z.object({
  shop_id: z.string().describe('The shop ID to get listings for')
});
const getShopDetailsSchema = z.object({
  shop_id: z.string().describe('The shop ID to get details for')
});
const createListingSchema = z.object({
  shop_id: z.string().describe('The shop ID to create a listing for'),
  listing_data: z.object({
    title: z.string().describe('The title of the listing'),
    description: z.string().describe('The description of the listing'),
    price: z.string().describe('The price of the listing'),
    quantity: z.string().describe('The quantity available'),
    who_made: z.string().describe('Who made the item'),
    when_made: z.string().describe('When the item was made'),
    taxonomy_id: z.string().describe('The taxonomy ID for the listing category'),
    type: z.string().describe('The type of listing')
  }).describe('The data for the new listing')
});
export class EtsyMCPServer {
  private server: McpServer;
  private oauthServer: OAuthServer;
  private etsyApi: typeof etsyApi;
  private tokenStorage: TokenStorage;
  constructor(port: number = 3003) {
    this.oauthServer = new OAuthServer(port);
    this.etsyApi = etsyApi;
    this.tokenStorage = TokenStorage.getInstance();
    this.server = new McpServer({
      name: 'Etsy API',
      version: '1.0.0'
    });
    this.setupTools();
  }
  private setupTools() {
    // Authenticate Tool
    this.server.tool(
      'authenticate',
      'Authenticate with Etsy API',
      async (extra) => {
        try {
          await this.oauthServer.start();
          const authUrl = this.oauthServer.getAuthUrl();
          try {
            await open(authUrl);
          } catch (error) {
            console.error('Failed to open browser:', error);
            return {
              content: [{
                type: 'text' as const,
                text: `Please manually open this URL in your browser: ${authUrl}`
              }]
            };
          }
          return {
            content: [{
              type: 'text' as const,
              text: 'Please complete the authentication in your browser. The window will close automatically when done.'
            }]
          };
        } catch (error) {
          console.error('Authentication error:', error);
          return this.handleError(error);
        }
      }
    );
    // Get Listings Tool
    this.server.tool(
      'get_listings',
      'Get all listings for a shop',
      getListingsSchema,
      async (args, extra) => {
        try {
          const tokens = this.tokenStorage.getTokens();
          if (!tokens?.access_token) {
            return this.handleError(new Error('Not authenticated. Please authenticate first.'));
          }
          const listings = await this.etsyApi.getListings(args.shop_id, tokens.access_token);
          return {
            content: [{
              type: 'text' as const,
              text: JSON.stringify(listings, null, 2)
            }]
          };
        } catch (error) {
          return this.handleError(error);
        }
      }
    );
    // Get Shop Details Tool
    this.server.tool(
      'get_shop_details',
      'Get details for a specific shop',
      getShopDetailsSchema,
      async (args, extra) => {
        try {
          const tokens = this.tokenStorage.getTokens();
          if (!tokens?.access_token) {
            return this.handleError(new Error('Not authenticated. Please authenticate first.'));
          }
          const shopDetails = await this.etsyApi.getShopDetails(args.shop_id, tokens.access_token);
          return {
            content: [{
              type: 'text' as const,
              text: JSON.stringify(shopDetails, null, 2)
            }]
          };
        } catch (error) {
          return this.handleError(error);
        }
      }
    );
    // Create Listing Tool
    this.server.tool(
      'create_listing',
      'Create a new Etsy listing',
      createListingSchema,
      async (args, extra) => {
        try {
          const tokens = this.tokenStorage.getTokens();
          if (!tokens?.access_token) {
            return this.handleError(new Error('Not authenticated. Please authenticate first.'));
          }
          const listingData = {
            ...args.listing_data,
            price: parseFloat(args.listing_data.price),
            quantity: parseInt(args.listing_data.quantity, 10),
            taxonomy_id: parseInt(args.listing_data.taxonomy_id, 10)
          };
          const newListing = await this.etsyApi.createListing(
            args.shop_id,
            listingData,
            tokens.access_token
          );
          return {
            content: [{
              type: 'text' as const,
              text: JSON.stringify(newListing, null, 2)
            }]
          };
        } catch (error) {
          return this.handleError(error);
        }
      }
    );
  }
  private handleError(error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    return {
      content: [{
        type: 'text' as const,
        text: `Error: ${errorMessage}`
      }],
      isError: true
    };
  }
  async start() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
  }
  async stop() {
    try {
      await this.server.close();
      this.oauthServer.stop();
      console.error('MCP server stopped successfully');
    } catch (error) {
      console.error('Failed to stop MCP server:', error);
      throw error;
    }
  }
}
</file>

<file path="src/services/oauthServer.ts">
import express, { Request, Response } from 'express';
import { Server } from 'http';
import { TokenStorage } from './tokenStorage.js';
import axios from 'axios';
import * as dotenv from 'dotenv';
import { etsyApi } from './etsyApi.js';
import crypto from 'crypto';
import { logger } from '../utils/logger.js';
dotenv.config();
export class OAuthServer {
    private app: express.Application;
    private server: Server | null = null;
    private codeVerifier: string;
    private codeChallenge: string;
    private tokenStorage: TokenStorage;
    private port: number;
    private host: string;
    constructor(port: number = 3003) {
        this.app = express();
        this.port = port;
        this.host = process.env.ETSY_MCP_HOST || 'localhost';
        this.tokenStorage = TokenStorage.getInstance();
        // Initialize PKCE values with default values
        this.codeVerifier = '';
        this.codeChallenge = '';
        this.setupRoutes();
        this.initializePKCE();
    }
    private async initializePKCE() {
        logger.log('Initializing PKCE...');
        // Generate a random string between 43-128 characters
        const length = Math.floor(Math.random() * (128 - 43 + 1)) + 43;
        const randomBytes = crypto.randomBytes(length);
        // Convert to base64 and ensure it only contains valid characters
        this.codeVerifier = randomBytes
            .toString('base64')
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '')
            .substring(0, length);
        // Generate code challenge using SHA-256
        this.codeChallenge = crypto
            .createHash('sha256')
            .update(this.codeVerifier)
            .digest('base64')
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');
        // Validate the code verifier format
        if (!/^[A-Za-z0-9._~-]{43,128}$/.test(this.codeVerifier)) {
            const error = new Error('Invalid code verifier format');
            logger.error('PKCE initialization failed', error);
            throw error;
        }
        logger.log('PKCE initialized successfully', {
            codeVerifierLength: this.codeVerifier.length,
            codeChallengeLength: this.codeChallenge.length,
            codeVerifierFormat: 'Valid',
            codeChallengeMethod: 'S256'
        });
    }
    private setupRoutes() {
        // Route to initiate OAuth flow
        this.app.get('/auth', async (_req: Request, res: Response) => {
            try {
                logger.log('Starting OAuth flow...');
                await this.initializePKCE();
                const authUrl = this.generateAuthUrl();
                logger.log('Redirecting to Etsy OAuth page', { authUrl });
                res.redirect(authUrl);
            } catch (error) {
                logger.error('Error initializing OAuth flow', error);
                res.status(500).send(`
                    <html>
                        <body>
                            <h1>Authentication Failed</h1>
                            <p>Error initializing OAuth flow: ${error instanceof Error ? error.message : String(error)}</p>
                            <script>
                                setTimeout(() => window.close(), 3000);
                            </script>
                        </body>
                    </html>
                `);
            }
        });
        // OAuth callback route
        this.app.get('/oauth/callback', async (req: Request, res: Response) => {
            try {
                const { code, error, error_description } = req.query;
                logger.log('Received OAuth callback', { code: code ? 'present' : 'missing', error, error_description });
                if (error) {
                    logger.error('OAuth error received', { error, error_description });
                    res.status(400).send(`
                        <html>
                            <body>
                                <h1>Authentication Failed</h1>
                                <p>Error: ${error}</p>
                                <p>Description: ${error_description || 'No description provided'}</p>
                                <script>
                                    console.error('OAuth error:', ${JSON.stringify({ error, error_description })});
                                    setTimeout(() => window.close(), 3000);
                                </script>
                            </body>
                        </html>
                    `);
                    return;
                }
                if (!code || typeof code !== 'string') {
                    logger.error('No authorization code received', new Error('Missing authorization code'));
                    res.status(400).send(`
                        <html>
                            <body>
                                <h1>Authentication Failed</h1>
                                <p>No authorization code received</p>
                                <script>
                                    console.error('No authorization code received');
                                    setTimeout(() => window.close(), 3000);
                                </script>
                            </body>
                        </html>
                    `);
                    return;
                }
                logger.log('Processing OAuth callback', {
                    code: `${code.substring(0, 10)}...`,
                    codeVerifier: `${this.codeVerifier.substring(0, 10)}...`,
                    codeChallenge: `${this.codeChallenge.substring(0, 10)}...`
                });
                try {
                    // Exchange code for tokens
                    logger.log('Exchanging code for tokens...');
                    const tokens = await this.exchangeCodeForTokens(code);
                    logger.log('Token exchange successful', { 
                        accessToken: tokens.access_token ? 'present' : 'missing',
                        refreshToken: tokens.refresh_token ? 'present' : 'missing'
                    });
                    // Store tokens
                    await this.tokenStorage.saveTokens(tokens);
                    etsyApi.setAccessToken(tokens.access_token);
                    // Send success response with auto-close
                    res.status(200).send(`
                        <html>
                            <body>
                                <h1>Authentication Successful!</h1>
                                <p>You can close this window and return to the application.</p>
                                <script>
                                    console.log('Authentication successful');
                                    setTimeout(() => window.close(), 2000);
                                </script>
                            </body>
                        </html>
                    `);
                    // Stop the server after successful authentication
                    setTimeout(() => this.stop(), 2500);
                } catch (exchangeError: any) {
                    logger.error('Token exchange failed', exchangeError);
                    const errorMessage = exchangeError.response?.data?.error_description || 
                                      exchangeError.response?.data?.error ||
                                      exchangeError.message;
                    res.status(500).send(`
                        <html>
                            <body>
                                <h1>Authentication Failed</h1>
                                <p>Error during token exchange: ${errorMessage}</p>
                                <script>
                                    console.error('Token exchange error:', ${JSON.stringify(errorMessage)});
                                    setTimeout(() => window.close(), 3000);
                                </script>
                            </body>
                        </html>
                    `);
                }
            } catch (error: any) {
                logger.error('Error in OAuth callback', error);
                res.status(500).send(`
                    <html>
                        <body>
                            <h1>Authentication Failed</h1>
                            <p>Error: ${error.message}</p>
                            <script>
                                console.error('Authentication error:', ${JSON.stringify(error.message)});
                                setTimeout(() => window.close(), 3000);
                            </script>
                        </body>
                    </html>
                `);
            }
        });
    }
    private generateAuthUrl(): string {
        if (!process.env.ETSY_API_KEY) {
            const error = new Error('Missing ETSY_API_KEY in environment variables');
            logger.error('Failed to generate auth URL', error);
            throw error;
        }
        const params = new URLSearchParams({
            response_type: 'code',
            client_id: process.env.ETSY_API_KEY,
            redirect_uri: `http://${this.host}:${this.port}/oauth/callback`,
            scope: 'listings_r listings_w shops_r',
            state: Math.random().toString(36).substring(7),
            code_challenge: this.codeChallenge,
            code_challenge_method: 'S256'
        });
        const authUrl = `https://www.etsy.com/oauth/connect?${params.toString()}`;
        logger.log('Generated auth URL', { 
            url: authUrl,
            params: Object.fromEntries(params)
        });
        return authUrl;
    }
    private async exchangeCodeForTokens(code: string) {
        const tokenEndpoint = 'https://api.etsy.com/v3/public/oauth/token';
        if (!process.env.ETSY_API_KEY || !process.env.ETSY_CLIENT_SECRET) {
            const error = new Error('Missing ETSY_API_KEY or ETSY_CLIENT_SECRET in environment variables');
            logger.error('Failed to exchange code for tokens', error);
            throw error;
        }
        const formData = new URLSearchParams({
            grant_type: 'authorization_code',
            client_id: process.env.ETSY_API_KEY,
            redirect_uri: `http://${this.host}:${this.port}/oauth/callback`,
            code: code,
            code_verifier: this.codeVerifier
        });
        // Create Basic Auth header with client credentials
        const authString = Buffer.from(
            `${process.env.ETSY_API_KEY}:${process.env.ETSY_CLIENT_SECRET}`
        ).toString('base64');
        logger.log('Preparing token exchange request', {
            tokenEndpoint,
            clientId: process.env.ETSY_API_KEY,
            redirectUri: `http://${this.host}:${this.port}/oauth/callback`,
            codeLength: code.length,
            codeVerifierLength: this.codeVerifier.length,
            formData: Object.fromEntries(formData)
        });
        try {
            const response = await axios.post(
                tokenEndpoint,
                formData.toString(),
                {
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Authorization': `Basic ${authString}`
                    }
                }
            );
            logger.log('Token exchange response received', {
                status: response.status,
                hasAccessToken: !!response.data.access_token,
                hasRefreshToken: !!response.data.refresh_token
            });
            return response.data;
        } catch (error: any) {
            logger.error('Token exchange request failed', error);
            throw error;
        }
    }
    async start() {
        return new Promise<void>((resolve) => {
            this.server = this.app.listen(this.port, this.host, () => {
                logger.log(`OAuth server listening at http://${this.host}:${this.port}`);
                resolve();
            });
        });
    }
    stop() {
        if (this.server) {
            this.server.close(() => {
                logger.log('OAuth server stopped');
            });
            this.server = null;
        }
    }
    public getAuthUrl(): string {
        return `http://${this.host}:${this.port}/auth`;
    }
}
</file>

<file path="src/services/tokenStorage.ts">
import * as fs from 'fs';
import * as path from 'path';
import * as dotenv from 'dotenv';
dotenv.config();
interface TokenData {
    access_token: string;
    refresh_token?: string;
    expires_at?: number;
}
export class TokenStorage {
    private static instance: TokenStorage;
    private tokenFilePath: string;
    private fileStorageEnabled: boolean = true;
    private constructor() {
        // Get storage path from environment variable or use default
        const storagePath = process.env.ETSY_MCP_TOKEN_PATH || path.join(process.env.HOME || process.env.USERPROFILE || '', '.etsy-mcp');
        try {
            // Create config directory if it doesn't exist
            if (!fs.existsSync(storagePath)) {
                fs.mkdirSync(storagePath, { mode: 0o700, recursive: true });
            }
            this.tokenFilePath = path.join(storagePath, 'tokens.json');
        } catch (error: any) {
            // Handle EROFS and other file system errors
            if (error.code === 'EROFS' || error.code === 'EACCES') {
                console.error(`[TokenStorage] File storage disabled: ${error.message}`);
                this.fileStorageEnabled = false;
                this.tokenFilePath = '';
            } else {
                throw error; // Re-throw other errors
            }
        }
    }
    public static getInstance(): TokenStorage {
        if (!TokenStorage.instance) {
            TokenStorage.instance = new TokenStorage();
        }
        return TokenStorage.instance;
    }
    public saveTokens(tokens: TokenData): void {
        if (!this.fileStorageEnabled) {
            console.warn('[TokenStorage] Token persistence is disabled due to file system restrictions. Tokens will not be saved between sessions.');
            return;
        }
        try {
            // Add expiration time (1 hour from now) if not provided
            if (!tokens.expires_at) {
                tokens.expires_at = Date.now() + (60 * 60 * 1000); // 1 hour
            }
            // Write tokens to file with restricted permissions
            fs.writeFileSync(this.tokenFilePath, JSON.stringify(tokens, null, 2), {
                mode: 0o600,
                encoding: 'utf8'
            });
        } catch (error: any) {
            if (error.code === 'EROFS' || error.code === 'EACCES') {
                console.error('[TokenStorage] Failed to save tokens: File system is read-only');
                this.fileStorageEnabled = false;
            } else {
                console.error('Error saving tokens:', error);
                throw error;
            }
        }
    }
    public getTokens(): TokenData | null {
        if (!this.fileStorageEnabled) {
            return null;
        }
        try {
            if (!fs.existsSync(this.tokenFilePath)) {
                return null;
            }
            const data = fs.readFileSync(this.tokenFilePath, 'utf8');
            const tokens: TokenData = JSON.parse(data);
            // Check if token is expired
            if (tokens.expires_at && tokens.expires_at < Date.now()) {
                return null;
            }
            return tokens;
        } catch (error: any) {
            if (error.code === 'EROFS' || error.code === 'EACCES') {
                console.error('[TokenStorage] Failed to read tokens: File system is read-only');
                this.fileStorageEnabled = false;
            } else {
                console.error('Error reading tokens:', error);
            }
            return null;
        }
    }
    public clearTokens(): void {
        if (!this.fileStorageEnabled) {
            return;
        }
        try {
            if (fs.existsSync(this.tokenFilePath)) {
                fs.unlinkSync(this.tokenFilePath);
            }
        } catch (error: any) {
            if (error.code === 'EROFS' || error.code === 'EACCES') {
                console.error('[TokenStorage] Failed to clear tokens: File system is read-only');
                this.fileStorageEnabled = false;
            } else {
                console.error('Error clearing tokens:', error);
                throw error;
            }
        }
    }
    public hasValidToken(): boolean {
        const tokens = this.getTokens();
        return tokens !== null && tokens.access_token !== undefined;
    }
}
</file>

<file path="src/types/modelcontextprotocol.d.ts">
declare module '@modelcontextprotocol/sdk' {
    export class MCPServer {
        constructor(options: {
            name: string;
            description: string;
            version: string;
            tools?: any;
        });
        start(): Promise<void>;
        stop(): Promise<void>;
    }
    export function tool(options: {
        name: string;
        description: string;
        parameters: {
            type: string;
            properties: Record<string, any>;
            required?: string[];
        };
    }): MethodDecorator;
}
</file>

<file path="src/utils/logger.ts">
import fs from 'fs';
import path from 'path';
class Logger {
    private logFile: string = '';
    private stream: fs.WriteStream | null = null;
    private fileLoggingEnabled: boolean = true;
    constructor() {
        // Get log directory from environment variable or use default
        const logDir = process.env.ETSY_MCP_LOG_PATH || path.join(process.cwd(), 'logs');
        try {
            // Create logs directory if it doesn't exist
            if (!fs.existsSync(logDir)) {
                fs.mkdirSync(logDir, { recursive: true });
            }
            // Create a new log file with timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            this.logFile = path.join(logDir, `oauth-${timestamp}.log`);
            this.stream = fs.createWriteStream(this.logFile, { flags: 'a' });
        } catch (error: any) {
            // Handle EROFS and other file system errors
            if (error.code === 'EROFS' || error.code === 'EACCES') {
                console.error(`[Logger] File logging disabled: ${error.message}`);
                this.fileLoggingEnabled = false;
                this.stream = null;
            } else {
                throw error; // Re-throw other errors
            }
        }
    }
    log(message: string, data?: any) {
        const timestamp = new Date().toISOString();
        const logEntry = {
            timestamp,
            message,
            data
        };
        // Write to console
        console.error(`[${timestamp}] ${message}`, data ? data : '');
        // Write to file if enabled
        if (this.fileLoggingEnabled && this.stream) {
            this.stream.write(JSON.stringify(logEntry) + '\n');
        }
    }
    error(message: string, error: any) {
        const timestamp = new Date().toISOString();
        const logEntry = {
            timestamp,
            level: 'error',
            message,
            error: {
                message: error.message,
                stack: error.stack,
                response: error.response?.data
            }
        };
        // Write to console
        console.error(`[${timestamp}] ERROR: ${message}`, error);
        // Write to file if enabled
        if (this.fileLoggingEnabled && this.stream) {
            this.stream.write(JSON.stringify(logEntry) + '\n');
        }
    }
    close() {
        if (this.stream) {
            this.stream.end(() => {
                console.log('Logger stream closed');
            });
        }
    }
}
export const logger = new Logger();
</file>

<file path="src/mcp.ts">
import { EtsyMCPServer } from "./services/mcpServer.js";
import { OAuthServer } from "./services/oauthServer.js";
import { etsyApi } from "./services/etsyApi.js";
// Initialize dependencies
const oauthServer = new OAuthServer();
// Create MCP server with dependencies
const server = new EtsyMCPServer(oauthServer);
// Handle errors without console.log
process.on('uncaughtException', (error) => {
  process.stderr.write(JSON.stringify({
    jsonrpc: "2.0",
    error: {
      code: -32000,
      message: error instanceof Error ? error.message : String(error)
    }
  }) + '\n');
  process.exit(1);
});
process.on('unhandledRejection', (reason) => {
  process.stderr.write(JSON.stringify({
    jsonrpc: "2.0",
    error: {
      code: -32000,
      message: reason instanceof Error ? reason.message : String(reason)
    }
  }) + '\n');
  process.exit(1);
});
process.on('SIGINT', async () => {
  try {
    await server.stop();
    process.exit(0);
  } catch (error) {
    process.stderr.write(JSON.stringify({
      jsonrpc: "2.0",
      error: {
        code: -32000,
        message: error instanceof Error ? error.message : String(error)
      }
    }) + '\n');
    process.exit(1);
  }
});
// Start server without console.log
server.start().catch(console.error);
</file>

<file path="docs.md">
# Etsy MCP Server Documentation

## Overview

Etsy MCP Server is a Model Context Protocol (MCP) server. It provides tools to interact with the Etsy API. This server allows you to manage Etsy listings and shop details programmatically.

## Quick Start

### Installation

1.  Install Node.js and npm.
2.  Clone the repository.
3.  Navigate to the repository directory in your terminal.
4.  Install dependencies:

    ```bash
    npm install
    ```

### Configuration

1.  Create a `.env` file in the repository's root directory.
2.  Add your Etsy API credentials to `.env`. You can copy the `.env.example` file and modify it.

    ```
    ETSY_API_KEY=your_api_key
    ETSY_CLIENT_SECRET=your_client_secret
    ```
    Obtain your Etsy API key and client secret from the Etsy Developer portal.

### Running the Server

1.  Start the server:

    ```bash
    npm start
    ```
    For development with auto-reload:

    ```bash
    npm run dev
    ```

The server will now be running and accessible via MCP clients.

## Available Tools

The Etsy MCP Server exposes the following tools:

### `createListing`

Creates a new Etsy listing.

**Parameters:**

*   `shop_id` (number): The ID of the Etsy shop.
*   `access_token` (string): Etsy OAuth access token for authentication.
*   `listing_data` (object): Data for the new listing.
    *   `title` (string): Title of the listing.
    *   `description` (string): Description of the listing.
    *   `price` (number): Price of the listing.
    *   `quantity` (number): Quantity of items for sale.
    *   `who_made` (string): Who made the listing ('i\_did', 'someone\_else', 'collective').
    *   `when_made` (string): When it was made ('made\_to\_order', '2020\_2024', etc.).
    *   `taxonomy_id` (number): Etsy category ID.
    *   `type` (string): Listing type ('physical' or 'digital').

### `getListings`

Retrieves all listings for a given Etsy shop.

**Parameters:**

*   `shop_id` (number): The ID of the Etsy shop.
*   `access_token` (string): Etsy OAuth access token for authentication.

### `getShopDetails`

Retrieves details of a specific Etsy shop.

**Parameters:**

*   `shop_id` (number): The ID of the Etsy shop.
*   `access_token` (string): Etsy OAuth access token for authentication.

## Dependencies

*   `@modelcontextprotocol/sdk`: Model Context Protocol SDK for server implementation.
*   `axios`: HTTP client for making requests to the Etsy API.
*   `dotenv`: Loads environment variables from `.env` file.
*   `zod`: Schema validation library.

## Advanced Usage

This documentation covers the basic setup and usage. For advanced configurations or extending the server, refer to the code and the Model Context Protocol SDK documentation.

## Example Usage

### Creating a New Listing

```typescript
const listingData = {
  title: "Handmade Ceramic Mug",
  description: "Beautiful handcrafted ceramic mug with unique design",
  price: 25.00,
  quantity: 1,
  who_made: "i_did",
  when_made: "2020_2024",
  taxonomy_id: 1234, // Replace with actual Etsy category ID
  type: "physical"
};

const params = {
  shop_id: 123456789,
  access_token: "your_access_token",
  listing_data: listingData
};

// Call the createListing tool
const response = await mcpServer.callTool('createListing', params);
```

### Getting Shop Listings

```typescript
const params = {
  shop_id: 123456789,
  access_token: "your_access_token"
};

// Call the getListings tool
const listings = await mcpServer.callTool('getListings', params);
```

## Error Handling

The server implements standard error handling for all API calls:

- All errors are returned in JSON-RPC 2.0 format
- Error responses include:
  - `code`: Error code (-32000 for server errors)
  - `message`: Detailed error message
  - `isError`: Set to true for error responses

Example error response:
```json
{
  "jsonrpc": "2.0",
  "error": {
    "code": -32000,
    "message": "Invalid access token"
  }
}
```

## Troubleshooting

Common issues and solutions:

1. **Authentication Errors**
   - Ensure your access token is valid and not expired
   - Check that your API credentials are correctly set in the .env file

2. **Invalid Shop ID**
   - Verify that the shop_id exists and belongs to your account
   - Ensure you have the necessary permissions to access the shop

3. **Rate Limiting**
   - The Etsy API has rate limits
   - Implement appropriate delays between requests if making multiple calls

4. **Server Connection Issues**
   - Check your internet connection
   - Verify the server is running and accessible
   - Check the server logs for any error messages

## Support

For additional support:
- Refer to the [Etsy API Documentation](https://www.etsy.com/developers/documentation/getting_started/oauth)
- Check the [Model Context Protocol Documentation](https://github.com/modelcontextprotocol/sdk)
- Review the project's GitHub issues for known problems and solutions
</file>

<file path="jest.config.cjs">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  moduleNameMapper: {
    '^@modelcontextprotocol/sdk/(.*)$': '<rootDir>/node_modules/@modelcontextprotocol/sdk/dist/cjs/$1',
  },
  transform: {
    '^.+\\.tsx?$': [
      'ts-jest',
      {
        tsconfig: {
          experimentalDecorators: true,
          emitDecoratorMetadata: true,
        },
      },
    ],
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
};
</file>

<file path="package.json">
{
  "name": "etsy-mcp",
  "version": "1.0.0",
  "type": "module",
  "main": "dist/mcp.js",
  "exports": {
    ".": {
      "import": "./dist/mcp.js",
      "require": "./dist/mcp.js"
    }
  },
  "scripts": {
    "build": "tsc",
    "start": "npm run build && node dist/mcp.js",
    "dev": "tsx watch src/mcp.ts",
    "test": "jest"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "MCP server for Etsy API integration",
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.8.0",
    "@types/express": "5.0.1",
    "@types/open": "^6.1.0",
    "axios": "^1.6.7",
    "dotenv": "^16.4.5",
    "express": "5.0.1",
    "open": "^10.1.0",
    "pkce-challenge": "^4.1.0",
    "zod": "3.23.8"
  },
  "devDependencies": {
    "@types/jest": "^29.5.14",
    "@types/node": "^20.11.24",
    "jest": "^29.7.0",
    "ts-jest": "^29.3.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "tsx": "^4.19.3",
    "typescript": "^5.3.3"
  },
  "ts-node": {
    "esm": true,
    "experimentalSpecifiers": true
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
</file>

<file path="README.md">
# Etsy MCP Server

A Model Context Protocol (MCP) server that provides tools for interacting with the Etsy API.

## Features

- Create new Etsy listings
- Get all listings for a shop
- Get shop details

## Setup

1. Install dependencies:
```bash
npm install
```

2. Configure environment variables:
Copy `.env.example` to `.env` and fill in your Etsy API credentials:
```
ETSY_API_KEY=your_api_key
ETSY_CLIENT_SECRET=your_client_secret
```

## Usage

Start the MCP server:
```bash
npm start
```

For development with auto-reload:
```bash
npm run dev
```

## Available Tools

### createListing
Create a new Etsy listing.

Parameters:
- `shopId` (string): The ID of the Etsy shop
- `accessToken` (string): The OAuth access token
- `listingData` (object): The listing data to create
  - `title` (string)
  - `description` (string)
  - `price` (number)
  - `quantity` (integer)
  - `who_made` (string)
  - `when_made` (string)
  - `taxonomy_id` (integer)
  - `type` (string)

### getListings
Get all listings for an Etsy shop.

Parameters:
- `shopId` (string): The ID of the Etsy shop
- `accessToken` (string): The OAuth access token

### getShopDetails
Get details for an Etsy shop.

Parameters:
- `shopId` (string): The ID of the Etsy shop
- `accessToken` (string): The OAuth access token
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "NodeNext",
    "lib": ["ES2020"],
    "moduleResolution": "NodeNext",
    "outDir": "./dist",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "types": ["node", "jest"],
    "allowJs": true,
    "resolveJsonModule": true,
    "typeRoots": ["./node_modules/@types"],
    "allowImportingTsExtensions": true,
    "noEmit": true,
    "paths": {
      "@modelcontextprotocol/sdk/*": ["./node_modules/@modelcontextprotocol/sdk/dist/esm/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"],
  "ts-node": {
    "esm": true,
    "experimentalSpecifiers": true,
    "transpileOnly": true
  }
}
</file>

</files>
